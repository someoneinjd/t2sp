[{"path":"/home/u146242/gbmv_lab/s10/a.cl", "name":"a.cl", "has_active_debug_locs":false, "absName":"/home/u146242/gbmv_lab/s10/a.cl", "content":"/*OpenCL C x86-64-linux-avx-avx2-enable_synthesis-f16c-fma-intel_fpga-opencl-sse41*/\u000A#pragma OPENCL FP_CONTRACT ON\u000A#define float_from_bits(x) as_float(x)\u000Ainline float nan_f32() { return NAN; }\u000Ainline float neg_inf_f32() { return -INFINITY; }\u000Ainline float inf_f32() { return INFINITY; }\u000Ainline bool is_nan_f32(float x) {return isnan(x); }\u000Ainline bool is_inf_f32(float x) {return isinf(x); }\u000Ainline bool is_finite_f32(float x) {return isfinite(x); }\u000A#define sqrt_f32 sqrt \u000A#define sin_f32 sin \u000A#define cos_f32 cos \u000A#define exp_f32 exp \u000A#define log_f32 log \u000A#define abs_f32 fabs \u000A#define floor_f32 floor \u000A#define ceil_f32 ceil \u000A#define round_f32 round \u000A#define trunc_f32 trunc \u000A#define pow_f32 pow\u000A#define asin_f32 asin \u000A#define acos_f32 acos \u000A#define tan_f32 tan \u000A#define atan_f32 atan \u000A#define atan2_f32 atan2\u000A#define sinh_f32 sinh \u000A#define asinh_f32 asinh \u000A#define cosh_f32 cosh \u000A#define acosh_f32 acosh \u000A#define tanh_f32 tanh \u000A#define atanh_f32 atanh \u000A#define fast_inverse_f32 native_recip \u000A#define fast_inverse_sqrt_f32 native_rsqrt \u000A#define __address_space___shared __local\u000A\u000A\u000A// ll suffix in OpenCL is reserved for 128-bit integers.\u000A#if defined __OPENCL_VERSION__\u000A#define ADD_INT64_T_SUFFIX(x) x##l\u000A#define ADD_UINT64_T_SUFFIX(x) x##ul\u000A// HLSL doesn't have any suffixes.\u000A#elif defined HLSL_VERSION\u000A#define ADD_INT64_T_SUFFIX(x) x\u000A#define ADD_UINT64_T_SUFFIX(x) x\u000A#else\u000A#define ADD_INT64_T_SUFFIX(x) x##ll\u000A#define ADD_UINT64_T_SUFFIX(x) x##ull\u000A#endif\u000A#pragma OPENCL EXTENSION cl_intel_channels : enable\u000Atypedef struct { float s[64]; } float64;\u000Atypedef union {\u000A    float s[64];\u000A    float16 v[4];\u000A} _aLoader_channel_array_t;\u000Achannel _aLoader_channel_array_t _aLoader_channel __attribute__((depth(1024))) ;\u000Achannel float64 _xLoader_channel __attribute__((depth(1024))) ;\u000Achannel float64 _xFeeder_channel __attribute__((depth(1024))) ;\u000Achannel float64 _V_channel __attribute__((depth(1024))) ;\u000Achannel float64 _yLoader_channel __attribute__((depth(1024))) ;\u000Achannel float64 _Out_channel __attribute__((depth(1024))) ;\u000A// Address spaces for kernel_aLoader\u000A#define __address_space__aSerializer __global\u000A__kernel void kernel_aLoader(\u000A const int _A_extent_0,\u000A const int _A_extent_1,\u000A __address_space__aSerializer const float *restrict _aSerializer_1,\u000A __address_space__aSerializer const float *restrict _aSerializer_2,\u000A __address_space__aSerializer const float *restrict _aSerializer_3,\u000A __address_space__aSerializer const float *restrict _aSerializer_4)\u000A{\u000A int _addr_temp = 0;\u000A int _0 = _A_extent_1 >> 11;\u000A for (int _aLoader_s0_i = 0; _aLoader_s0_i < 0 + _0; _aLoader_s0_i++)\u000A {\u000A  int _1 = _A_extent_0 >> 6;\u000A  for (int _aLoader_s0_k = 0; _aLoader_s0_k < 0 + _1; _aLoader_s0_k++)\u000A  {\u000A   for (int _aLoader_s0_kk_ii = 0; _aLoader_s0_kk_ii < 0 + 2048; _aLoader_s0_kk_ii++)\u000A   {\u000A    int _3 = _addr_temp;\u000A    int _4 = _3 * 16;\u000A    _aLoader_channel_array_t _temp;\u000A    _temp.v[0] = vload16(0, (__address_space__aSerializer float*)(_aSerializer_1 + _4));\u000A    _temp.v[1] = vload16(0, (__address_space__aSerializer float*)(_aSerializer_2 + _4));\u000A    _temp.v[2] = vload16(0, (__address_space__aSerializer float*)(_aSerializer_3 + _4));\u000A    _temp.v[3] = vload16(0, (__address_space__aSerializer float*)(_aSerializer_4 + _4));\u000A    write_channel_intel(_aLoader_channel, _temp);\u000A    _addr_temp += 1;\u000A   } // for _aLoader_s0_kk_ii\u000A  } // for _aLoader_s0_k\u000A } // for _aLoader_s0_i\u000A} // kernel kernel_aLoader\u000A#undef __address_space__aSerializer\u000A// Address spaces for kernel_xLoader\u000A#define __address_space__xSerializer_mem_channel __global\u000A__kernel void kernel_xLoader(\u000A const int _A_extent_0,\u000A const int _A_extent_1,\u000A __address_space__xSerializer_mem_channel const float *restrict _xSerializer_mem_channel)\u000A{\u000A int _addr_temp;\u000A _addr_temp = 0;\u000A int _15 = _A_extent_1 >> 11;\u000A for (int _xLoader_s0_i = 0; _xLoader_s0_i < 0 + _15; _xLoader_s0_i++)\u000A {\u000A  int _16 = _A_extent_0 >> 6;\u000A  for (int _xLoader_s0_k = 0; _xLoader_s0_k < 0 + _16; _xLoader_s0_k++)\u000A  {\u000A   for (int _xLoader_s0_kk_ii = 0; _xLoader_s0_kk_ii < 0 + 33; _xLoader_s0_kk_ii++)\u000A   {\u000A    int _17 = _addr_temp * 64;\u000A    float64 _18 = *((__address_space__xSerializer_mem_channel float64*)(_xSerializer_mem_channel + _17));\u000A    write_channel_intel(_xLoader_channel, _18);\u000A    (void)_18;\u000A    int _19 = _addr_temp + 1;\u000A    _addr_temp = _19;\u000A   } // for _xLoader_s0_kk_ii_iii\u000A  } // for _xLoader_s0_k\u000A } // for _xLoader_s0_i\u000A} // kernel kernel_xLoader\u000A#undef __address_space__xSerializer_mem_channel\u000A// Address spaces for kernel_xFeeder\u000A__kernel void kernel_xFeeder(\u000A const int _A_extent_0,\u000A const int _A_extent_1)\u000A{\u000A float64 __attribute__((register)) _xFeeder_channel_array;\u000A float64 __attribute__((register)) _xFeeder_value_shreg;\u000A uint _xFeeder_time_stamp_shreg;\u000A float64 __attribute__((register)) _xFeeder_in_v_temp;\u000A uint _xFeeder_cycle_temp;\u000A float __attribute__((memory, numbanks(64), bankwidth(4), singlepump, numwriteports(1), numreadports(1))) _xFeeder_DB_0_ibuffer[2][33][64];\u000A uint _20 = (uint)(ADD_UINT64_T_SUFFIX(2015));\u000A _xFeeder_cycle_temp = _20;\u000A int _21 = _A_extent_1 >> 11;\u000A int _22 = _A_extent_0 >> 6;\u000A int _23 = _21 * _22;\u000A int _24 = _23 * 2048;\u000A int _25 = _24 + 2048;\u000A for (int _xFeeder_s0_outermost_loop = 0; _xFeeder_s0_outermost_loop < 0 + _25; _xFeeder_s0_outermost_loop++)\u000A {\u000A  uint _26 = _xFeeder_cycle_temp;\u000A  uint _27 = (uint)(ADD_UINT64_T_SUFFIX(11));\u000A  uint _28 = _26 >> _27;\u000A  int _29 = (int)(_28);\u000A  int _30 = _A_extent_1 >> 11;\u000A  int _31 = _A_extent_0 >> 6;\u000A  int _32 = _30 * _31;\u000A  bool _33 = _29 < _32;\u000A  uint _34 = _26 & 2047;\u000A  bool _35 = 2015 <= _34;\u000A  bool _36 = _33 && _35;\u000A  if (_36)\u000A  {\u000A   float64 __34 = read_channel_intel(_xLoader_channel);\u000A   _xFeeder_in_v_temp = __34;\u000A  } // if _33\u000A  #pragma unroll\u000A  for (int _xFeeder_s0_buf = 0; _xFeeder_s0_buf < 0 + 64; _xFeeder_s0_buf++)\u000A  {\u000A   bool _35 = _xFeeder_s0_buf == 0;\u000A   if (_35)\u000A   {\u000A    _xFeeder_value_shreg = _xFeeder_in_v_temp;\u000A    _xFeeder_time_stamp_shreg = _xFeeder_cycle_temp;\u000A   } // if _35\u000A   else\u000A   {\u000A    _xFeeder_value_shreg = _xFeeder_value_shreg;\u000A    _xFeeder_time_stamp_shreg = _xFeeder_time_stamp_shreg;\u000A   } // if _35 else\u000A   _xFeeder_value_shreg = __fpga_reg(__fpga_reg(_xFeeder_value_shreg));\u000A   _xFeeder_time_stamp_shreg = __fpga_reg(__fpga_reg(_xFeeder_time_stamp_shreg));\u000A\u000A   uint _49 = _xFeeder_cycle_temp;\u000A   uint _50 = (uint)(ADD_UINT64_T_SUFFIX(2047));\u000A   uint _51 = _49 & _50;\u000A   uint _52 = (uint)(ADD_UINT64_T_SUFFIX(2015));\u000A   bool _53 = _52 <= _51;\u000A   if (_53)\u000A   {\u000A    uint _59 = _xFeeder_cycle_temp;\u000A    uint _60 = (uint)(ADD_UINT64_T_SUFFIX(11));\u000A    uint _61 = _59 >> _60;\u000A    uint _62 = (uint)(ADD_UINT64_T_SUFFIX(1));\u000A    uint _63 = _61 & _62;\u000A    bool _64 = (bool)(_63); \u000A    uint _66 = (uint)(ADD_UINT64_T_SUFFIX(2047));\u000A    uint _67 = _59 & _66;\u000A    uint _68 = _67 - 2015;\u000A    _xFeeder_DB_0_ibuffer[_64][_68][_xFeeder_s0_buf] = _xFeeder_value_shreg.s[_xFeeder_s0_buf];\u000A   } // if _55\u000A   uint _74 = _xFeeder_time_stamp_shreg;\u000A   uint _75 = (uint)(ADD_UINT64_T_SUFFIX(11));\u000A   uint _76 = _74 >> _75;\u000A   int _77 = (int)(_76);\u000A   int _78 = _A_extent_1 >> 11;\u000A   int _79 = _A_extent_0 >> 6;\u000A   int _80 = _78 * _79;\u000A   bool _81 = _77 <= _80;\u000A   uint _82 = (uint)(ADD_UINT64_T_SUFFIX(0));\u000A   bool _84 = _82 < _76;\u000A   bool _85 = _81 && _84;\u000A   if (_85)\u000A   {\u000A    uint _93 = _xFeeder_time_stamp_shreg;\u000A    uint _94 = (uint)(ADD_UINT64_T_SUFFIX(11));\u000A    uint _95 = _93 >> _94;\u000A    uint _96 = (uint)(ADD_UINT64_T_SUFFIX(1));\u000A    uint _97 = _95 & _96;\u000A    bool _98 = (bool)(_97);\u000A    bool _99 = !(_98);\u000A    uint _101 = (uint)(ADD_UINT64_T_SUFFIX(2047));\u000A    uint _102 = _93 & _101;\u000A    uint _ii = _102 & 31;\u000A    uint _kk = _102 >> 5;\u000A    uint _word = (64*_ii + _kk) >> 6;\u000A    uint _elem = (64*_ii + _kk) & 63;\u000A    uint _word_off = (64 - _elem + _xFeeder_s0_buf) >> 6;\u000A    uint _addr = _word + (1 - _word_off);\u000A    float _107 = _xFeeder_DB_0_ibuffer[_99][_addr][_xFeeder_s0_buf];\u000A    uint _elem_off = (64 - _elem + _xFeeder_s0_buf) & 63;\u000A    _xFeeder_channel_array.s[_elem_off] = _107;\u000A    (void)_xFeeder_s0_buf;\u000A   } // if _91\u000A  } // for _xFeeder_s0_buf\u000A  uint _109 = _xFeeder_time_stamp_shreg;\u000A  uint _110 = (uint)(ADD_UINT64_T_SUFFIX(11));\u000A  uint _111 = _109 >> _110;\u000A  int _112 = (int)(_111);\u000A  int _113 = _A_extent_1 >> 11;\u000A  int _114 = _A_extent_0 >> 6;\u000A  int _115 = _113 * _114;\u000A  bool _116 = _112 <= _115;\u000A  uint _123 = (uint)(ADD_UINT64_T_SUFFIX(0));\u000A  bool _125 = _123 < _112;\u000A  bool _126 = _116 && _125;\u000A  if (_126)\u000A  {\u000A   write_channel_intel(_xFeeder_channel, _xFeeder_channel_array);\u000A   (void)_xFeeder_channel_array;\u000A  } // if _126\u000A  uint _127 = _xFeeder_cycle_temp;\u000A  uint _128 = (uint)(ADD_UINT64_T_SUFFIX(1));\u000A  uint _129 = _127 + _128;\u000A  _xFeeder_cycle_temp = _129;\u000A } // for _xFeeder_s0_outermost_loop\u000A} // kernel kernel_xFeeder\u000A// Address spaces for kernel_V\u000A__kernel void kernel_V(\u000A const int _A_extent_0,\u000A const int _A_extent_1)\u000A{\u000A float64 _xFeeder_channel_array;\u000A _aLoader_channel_array_t _aLoader_channel_array;\u000A float64 _V_channel_array;\u000A // produce uZ\u000A float _uZ_shreg[32][64];\u000A // produce uX\u000A float _uX_shreg[64];\u000A float _uZ_temp[64];\u000A // produce uA\u000A float _uA_shreg[64];\u000A int _130 = _A_extent_1 >> 11;\u000A for (int _uA_s0_i = 0; _uA_s0_i < 0 + _130; _uA_s0_i++)\u000A {\u000A  int _131 = _A_extent_0 >> 6;\u000A  for (int _uA_s0_k = 0; _uA_s0_k < 0 + _131; _uA_s0_k++)\u000A  {\u000A   for (int _uA_s0_kk_ii = 0; _uA_s0_kk_ii < 0 + 2048; _uA_s0_kk_ii++)\u000A   {\u000A    #pragma unroll\u000A    for (int _dummy_s0_iii = 0; _dummy_s0_iii < 0 + 64; _dummy_s0_iii++)\u000A    {\u000A     float _133 = _uZ_shreg[31][_dummy_s0_iii];\u000A     _uZ_temp[_dummy_s0_iii] = _133;\u000A     #pragma unroll\u000A     for (int _dummy__1_s0_l0 = 0; _dummy__1_s0_l0 < 0 + 31; _dummy__1_s0_l0++)\u000A     {\u000A      int _134 = 31 - _dummy__1_s0_l0;\u000A      int _135 = 30 - _dummy__1_s0_l0;\u000A      float _137 = _uZ_shreg[_135][_dummy_s0_iii];\u000A      _uZ_shreg[_134][_dummy_s0_iii] = _137;\u000A      (void)_137;\u000A     } // for _dummy__1_s0_l0\u000A     float _138 = _uZ_temp[_dummy_s0_iii];\u000A     _uZ_shreg[0][_dummy_s0_iii] = _138;\u000A     (void)_138;\u000A    } // for _dummy_s0_iii\u000A    bool _V_channel_temp;\u000A    _V_channel_temp = 0;\u000A    float64 __139 = read_channel_intel(_xFeeder_channel);\u000A    _xFeeder_channel_array = __139;\u000A    (void)__139;\u000A    _aLoader_channel_array_t __140 = read_channel_intel(_aLoader_channel);\u000A    _aLoader_channel_array = __140;\u000A    (void)__140;\u000A    #pragma unroll\u000A    for (int _uA_s0_iii = 0; _uA_s0_iii < 0 + 64; _uA_s0_iii++)\u000A    {\u000A     float __141 = _aLoader_channel_array.s[_uA_s0_iii];\u000A     _uA_shreg[_uA_s0_iii] = __141;\u000A     (void)__141;\u000A     float __142 = _xFeeder_channel_array.s[_uA_s0_iii];\u000A     _uX_shreg[_uA_s0_iii] = __142;\u000A     (void)__142;\u000A     float _143;\u000A     int _144 = _uA_s0_kk_ii >> 5;\u000A     int _145 = _uA_s0_k * 64;\u000A     int _146 = _144 + _145;\u000A     bool _147 = _146 == 0;\u000A     if (_147)\u000A     {\u000A      float _148 = float_from_bits(0 /* 0 */);\u000A      _143 = _148;\u000A     } // if _147\u000A     else\u000A     {\u000A      float _150 = _uZ_shreg[0][_uA_s0_iii];\u000A      _143 = _150;\u000A     } // if _147 else\u000A     float _151 = _143;\u000A     float _153 = _uA_shreg[_uA_s0_iii];\u000A     float _155 = _uX_shreg[_uA_s0_iii];\u000A     float _156 = _153 * _155;\u000A     float _157 = _151 + _156;\u000A     _uZ_shreg[0][_uA_s0_iii] = _157;\u000A     (void)_157;\u000A     int _158 = _uA_s0_kk_ii >> 5;\u000A     bool _159 = _158 == 63;\u000A     int _160 = _A_extent_0 >> 6;\u000A     int _161 = _160 + -1;\u000A     bool _162 = _uA_s0_k == _161;\u000A     bool _163 = _159 && _162;\u000A     if (_163)\u000A     {\u000A      float _165 = _uZ_shreg[0][_uA_s0_iii];\u000A      _V_channel_array.s[_uA_s0_iii] = _165;\u000A      (void)_uA_s0_iii;\u000A      _V_channel_temp = 1;\u000A     } // if _163\u000A    } // for _uA_s0_iii\u000A    bool _166 = _V_channel_temp;\u000A    if (_166)\u000A    {\u000A     write_channel_intel(_V_channel, _V_channel_array);\u000A     (void)_V_channel_array;\u000A    } // if _166\u000A   } // for _uA_s0_kk_ii\u000A  } // for _uA_s0_k\u000A } // for _uA_s0_i\u000A} // kernel kernel_V\u000A// Address spaces for kernel_yLoader\u000A#define __address_space__ySerializer_mem_channel __global\u000A__kernel void kernel_yLoader(\u000A const int _A_extent_1,\u000A __address_space__ySerializer_mem_channel const float *restrict _ySerializer_mem_channel)\u000A{\u000A int _addr_temp;\u000A _addr_temp = 0;\u000A int _167 = _A_extent_1 >> 11;\u000A for (int _yLoader_s0_i = 0; _yLoader_s0_i < 0 + _167; _yLoader_s0_i++)\u000A {\u000A  for (int _yLoader_s0_ii = 0; _yLoader_s0_ii < 0 + 32; _yLoader_s0_ii++)\u000A  {\u000A   int _168 = _addr_temp;\u000A   int _169 = _168 * 64;\u000A   float64 _170 = *((__address_space__ySerializer_mem_channel float64*)(_ySerializer_mem_channel + _169));\u000A   write_channel_intel(_yLoader_channel, _170);\u000A   (void)_169;\u000A   int _171 = _168 + 1;\u000A   _addr_temp = _171;\u000A  } // for _yLoader_s0_ii_iii\u000A } // for _yLoader_s0_i\u000A} // kernel kernel_yLoader\u000A#undef __address_space__ySerializer_mem_channel\u000A// Address spaces for kernel_Out\u000A__kernel void kernel_Out(\u000A const int _A_extent_1,\u000A const float _Alpha,\u000A const float _Beta)\u000A{\u000A int _171 = _A_extent_1 >> 11;\u000A for (int _Out_s0_i = 0; _Out_s0_i < 0 + _171; _Out_s0_i++)\u000A {\u000A  for (int _Out_s0_ii = 0; _Out_s0_ii < 0 + 32; _Out_s0_ii++)\u000A  {\u000A   float64 __172 = read_channel_intel(_V_channel);\u000A   float64 __274 = read_channel_intel(_yLoader_channel);\u000A   float64 _277;\u000A   #pragma unroll\u000A   for (int _Out_s0_iii = 0; _Out_s0_iii < 0 + 64; _Out_s0_iii++)\u000A   {\u000A    _277.s[_Out_s0_iii] = _Alpha * __172.s[_Out_s0_iii] + _Beta * __274.s[_Out_s0_iii];\u000A   } // for _Out_s0_iii\u000A   write_channel_intel(_Out_channel, _277);\u000A   (void)_277;\u000A  } // for _Out_s0_ii\u000A } // for _Out_s0_i\u000A} // kernel kernel_Out\u000A// Address spaces for kernel_unloader\u000A#define __address_space__unloader_mem_channel __global\u000A__kernel void kernel_unloader(\u000A const int _A_extent_1,\u000A __address_space__unloader_mem_channel float *restrict _unloader_mem_channel)\u000A{\u000A int _addr_temp;\u000A _addr_temp = 0;\u000A int _178 = _A_extent_1 >> 11;\u000A for (int _unloader_s0_i = 0; _unloader_s0_i < 0 + _178; _unloader_s0_i++)\u000A {\u000A  for (int _unloader_s0_ii = 0; _unloader_s0_ii < 0 + 32; _unloader_s0_ii++)\u000A  {\u000A   float64 __179 = read_channel_intel(_Out_channel);\u000A   int _180 = _addr_temp * 64;\u000A   *((__address_space__unloader_mem_channel float64*)(_unloader_mem_channel + _180)) = __179;\u000A   int _181 = _addr_temp;\u000A   int _182 = _181 + 1;\u000A   _addr_temp = _182;\u000A  } // for _unloader_s0_ii_iii\u000A } // for _unloader_s0_i\u000A} // kernel kernel_unloader\u000A#undef __address_space__unloader_mem_channel\u000A\u000A"}]