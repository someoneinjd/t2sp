[{"path":"/home/u146242/ger_lab/s10_1/a.cl", "name":"a.cl", "has_active_debug_locs":false, "absName":"/home/u146242/ger_lab/s10_1/a.cl", "content":"/*OpenCL C x86-64-linux-avx-avx2-enable_synthesis-f16c-fma-intel_fpga-opencl-sse41*/\u000A#pragma OPENCL FP_CONTRACT ON\u000A#define float_from_bits(x) as_float(x)\u000Ainline float nan_f32() { return NAN; }\u000Ainline float neg_inf_f32() { return -INFINITY; }\u000Ainline float inf_f32() { return INFINITY; }\u000Ainline bool is_nan_f32(float x) {return isnan(x); }\u000Ainline bool is_inf_f32(float x) {return isinf(x); }\u000Ainline bool is_finite_f32(float x) {return isfinite(x); }\u000A#define sqrt_f32 sqrt \u000A#define sin_f32 sin \u000A#define cos_f32 cos \u000A#define exp_f32 exp \u000A#define log_f32 log \u000A#define abs_f32 fabs \u000A#define floor_f32 floor \u000A#define ceil_f32 ceil \u000A#define round_f32 round \u000A#define trunc_f32 trunc \u000A#define pow_f32 pow\u000A#define asin_f32 asin \u000A#define acos_f32 acos \u000A#define tan_f32 tan \u000A#define atan_f32 atan \u000A#define atan2_f32 atan2\u000A#define sinh_f32 sinh \u000A#define asinh_f32 asinh \u000A#define cosh_f32 cosh \u000A#define acosh_f32 acosh \u000A#define tanh_f32 tanh \u000A#define atanh_f32 atanh \u000A#define fast_inverse_f32 native_recip \u000A#define fast_inverse_sqrt_f32 native_rsqrt \u000A#define __address_space___shared __local\u000A\u000A\u000A// ll suffix in OpenCL is reserved for 128-bit integers.\u000A#if defined __OPENCL_VERSION__\u000A#define ADD_INT64_T_SUFFIX(x) x##l\u000A#define ADD_UINT64_T_SUFFIX(x) x##ul\u000A// HLSL doesn't have any suffixes.\u000A#elif defined HLSL_VERSION\u000A#define ADD_INT64_T_SUFFIX(x) x\u000A#define ADD_UINT64_T_SUFFIX(x) x\u000A#else\u000A#define ADD_INT64_T_SUFFIX(x) x##ll\u000A#define ADD_UINT64_T_SUFFIX(x) x##ull\u000A#endif\u000A#pragma OPENCL EXTENSION cl_intel_channels : enable\u000Atypedef struct { float s; } _xLoader_channel_array_t;\u000Achannel _xLoader_channel_array_t _xLoader_channel __attribute__((depth(256))) ;\u000Achannel float _yLoader_channel __attribute__((depth(256))) ;\u000Atypedef struct { float s[32]; } _yFeeder_channel_array_t;\u000Achannel _yFeeder_channel_array_t _yFeeder_channel __attribute__((depth(256))) ;\u000Atypedef union {\u000A    float s[32];\u000A    float16 v[2];\u000A} _aLoader_channel_array_t;\u000Achannel _aLoader_channel_array_t _aLoader_channel __attribute__((depth(256))) ;\u000Atypedef union {\u000A    float s[32];\u000A    float16 v[2];\u000A} _uZ_channel_array_t;\u000Achannel _uZ_channel_array_t _uZ_channel __attribute__((depth(256))) ;\u000A// Address spaces for kernel_xLoader\u000A#define __address_space__X_serializer_mem_channel __global\u000A__kernel void kernel_xLoader(\u000A const int _A_extent_0,\u000A const int _A_extent_1,\u000A __address_space__X_serializer_mem_channel const float *restrict _X_serializer_mem_channel)\u000A{\u000A _xLoader_channel_array_t _xLoader_channel_array;\u000A int _0 = _A_extent_1 >> 5;\u000A for (int _xLoader_s0_i = 0; _xLoader_s0_i < 0 + _0; _xLoader_s0_i++)\u000A {\u000A  int _1 = _A_extent_0 >> 5;\u000A  for (int _xLoader_s0_j = 0; _xLoader_s0_j < 0 + _1; _xLoader_s0_j++)\u000A  {\u000A    for (int _xLoader_s0_ii = 0; _xLoader_s0_ii < 0 + 32; _xLoader_s0_ii++)\u000A    {\u000A      int _3 = _xLoader_s0_ii + 32*_xLoader_s0_i;\u000A      float _10 = _X_serializer_mem_channel[_3];\u000A      _xLoader_channel_array.s = _10;\u000A      write_channel_intel(_xLoader_channel, _xLoader_channel_array);\u000A      (void)_xLoader_channel_array;\u000A   } // for _xLoader_s0_ii\u000A  } // for _xLoader_s0_j\u000A } // for _xLoader_s0_i\u000A} // kernel kernel_xLoader\u000A#undef __address_space__X_serializer_mem_channel\u000A// Address spaces for kernel_yLoader\u000A#define __address_space__Y_serializer_mem_channel __global\u000A__kernel void kernel_yLoader(\u000A const int _A_extent_0,\u000A const int _A_extent_1,\u000A __address_space__Y_serializer_mem_channel const float *restrict _Y_serializer_mem_channel)\u000A{\u000A int _12 = _A_extent_1 >> 5;\u000A int _13 = _12 + 1;\u000A for (int _yLoader_s0_i = 0; _yLoader_s0_i < 0 + _13; _yLoader_s0_i++)\u000A {\u000A  int _14 = _A_extent_0 >> 5;\u000A  for (int _yLoader_s0_j = 0; _yLoader_s0_j < 0 + _14; _yLoader_s0_j++)\u000A  {\u000A   for (int _yLoader_s0_jj = 0; _yLoader_s0_jj < 0 + 32; _yLoader_s0_jj++)\u000A   {\u000A    bool _15 = _yLoader_s0_j == 0;\u000A    int _18 = _A_extent_1 >> 5;\u000A    bool _19 = _yLoader_s0_i < _18;\u000A    bool _20 = _15 || _19;\u000A    if (_20)\u000A    {\u000A     float _21;\u000A     int _22 = _A_extent_1 >> 5;\u000A     bool _23 = _yLoader_s0_i < _22;\u000A     if (_23)\u000A     {\u000A      int _27 = _yLoader_s0_jj + 32*_yLoader_s0_j;\u000A      float _28 = _Y_serializer_mem_channel[_27];\u000A      _21 = _28;\u000A     } // if _23\u000A     else\u000A     {\u000A      float _29 = float_from_bits(0 /* 0 */);\u000A      _21 = _29;\u000A     } // if _23 else\u000A     float _30 = _21;\u000A     write_channel_intel(_yLoader_channel, _30);\u000A     (void)_30;\u000A    } // if _20\u000A   } // for _yLoader_s0_jj\u000A  } // for _yLoader_s0_j\u000A } // for _yLoader_s0_i\u000A} // kernel kernel_yLoader\u000A#undef __address_space__Y_serializer_mem_channel\u000A// Address spaces for kernel_yFeeder\u000A__attribute__((max_global_work_dim(0)))\u000A__attribute__((autorun))\u000A__kernel void kernel_yFeeder(\u000A)\u000A{\u000A _yFeeder_channel_array_t _yFeeder_channel_array;\u000A float _yFeeder_value_shreg;\u000A uint _yFeeder_time_stamp_shreg;\u000A float _yFeeder_in_v_temp;\u000A uint _yFeeder_cycle_temp;\u000A float __attribute__((memory, numbanks(32), singlepump, numwriteports(1), numreadports(1))) _yFeeder_DB_0_ibuffer[2][32];\u000A uint _33 = (uint)(ADD_UINT64_T_SUFFIX(0));\u000A _yFeeder_cycle_temp = _33;\u000A while(1)\u000A {\u000A  float __34 = read_channel_intel(_yLoader_channel);\u000A  _yFeeder_in_v_temp = __34;\u000A  #pragma unroll\u000A  for (int _yFeeder_s0_buf = 0; _yFeeder_s0_buf < 0 + 32; _yFeeder_s0_buf++)\u000A  {\u000A   bool _35 = _yFeeder_s0_buf == 0;\u000A   if (_35)\u000A   {\u000A    float _36 = _yFeeder_in_v_temp;\u000A    _yFeeder_value_shreg = _36;\u000A    (void)_36;\u000A    uint _37 = _yFeeder_cycle_temp;\u000A    _yFeeder_time_stamp_shreg = _37;\u000A    (void)_37;\u000A   } // if _35\u000A   else\u000A   {\u000A    float _39 = _yFeeder_value_shreg;\u000A    _yFeeder_value_shreg = _39;\u000A    (void)_39;\u000A    uint _41 = _yFeeder_time_stamp_shreg;\u000A    _yFeeder_time_stamp_shreg = _41;\u000A    (void)_41;\u000A   } // if _35 else\u000A   float _43 = _yFeeder_value_shreg;\u000A   float _44 = __fpga_reg(__fpga_reg(_43));\u000A   _yFeeder_value_shreg = _44;\u000A   (void)_44;\u000A   uint _46 = _yFeeder_time_stamp_shreg;\u000A   uint _47 = __fpga_reg(__fpga_reg(_46));\u000A   _yFeeder_time_stamp_shreg = _47;\u000A   (void)_47;\u000A   uint _49 = _yFeeder_time_stamp_shreg;\u000A   uint _50 = (uint)(ADD_UINT64_T_SUFFIX(31));\u000A   uint _51 = _49 & _50;\u000A   uint _52 = _51 & _50;\u000A   int _53 = (int)(_52);\u000A   bool _54 = _yFeeder_s0_buf == _53;\u000A   if (_54)\u000A   {\u000A    float _56 = _yFeeder_value_shreg;\u000A    uint _58 = _yFeeder_time_stamp_shreg;\u000A    uint _59 = (uint)(ADD_UINT64_T_SUFFIX(5));\u000A    uint _60 = _58 >> _59;\u000A    uint _61 = (uint)(ADD_UINT64_T_SUFFIX(1));\u000A    uint _62 = _60 & _61;\u000A    bool _63 = (bool)(_62);\u000A    _yFeeder_DB_0_ibuffer[_63][_yFeeder_s0_buf] = _56;\u000A   } // if _54\u000A   uint _65 = _yFeeder_time_stamp_shreg;\u000A   uint _66 = (uint)(ADD_UINT64_T_SUFFIX(5));\u000A   uint _67 = _65 >> _66;\u000A   uint _68 = (uint)(ADD_UINT64_T_SUFFIX(1));\u000A   uint _69 = _67 & _68;\u000A   bool _70 = (bool)(_69);\u000A   bool _71 = !(_70);\u000A   float _72 = _yFeeder_DB_0_ibuffer[_71][_yFeeder_s0_buf];\u000A   _yFeeder_channel_array.s[_yFeeder_s0_buf] = _72;\u000A   (void)_yFeeder_s0_buf;\u000A  } // for _yFeeder_s0_buf\u000A  uint _73 = (uint)(ADD_UINT64_T_SUFFIX(0));\u000A  uint _75 = _yFeeder_time_stamp_shreg;\u000A  uint _76 = (uint)(ADD_UINT64_T_SUFFIX(5));\u000A  uint _77 = _75 >> _76;\u000A  bool _78 = _73 < _77;\u000A  if (_78)\u000A  {\u000A   write_channel_intel(_yFeeder_channel, _yFeeder_channel_array);\u000A   (void)_yFeeder_channel_array;\u000A  } // if _78\u000A  uint _79 = _yFeeder_cycle_temp;\u000A  uint _80 = (uint)(ADD_UINT64_T_SUFFIX(1));\u000A  uint _81 = _79 + _80;\u000A  _yFeeder_cycle_temp = _81;\u000A } // while _yFeeder_s0_outermost_loop_infinite\u000A} // kernel kernel_yFeeder\u000A// Address spaces for kernel_aLoader\u000A#define __address_space__A_serializer __global\u000A__kernel void kernel_aLoader(\u000A const int _A_extent_0,\u000A const int _A_extent_1,\u000A __address_space__A_serializer const float *restrict _A_serializer_1,\u000A __address_space__A_serializer const float *restrict _A_serializer_2)\u000A{\u000A int _addr_temp = 0;\u000A _aLoader_channel_array_t _aLoader_channel_array;\u000A int _82 = _A_extent_1 >> 5;\u000A for (int _aLoader_s0_i = 0; _aLoader_s0_i < 0 + _82; _aLoader_s0_i++)\u000A {\u000A  int _83 = _A_extent_0 >> 5;\u000A  for (int _aLoader_s0_j = 0; _aLoader_s0_j < 0 + _83; _aLoader_s0_j++)\u000A  {\u000A   for (int _aLoader_s0_ii = 0; _aLoader_s0_ii < 0 + 32; _aLoader_s0_ii++)\u000A   {\u000A    int _84 = _addr_temp;\u000A    int _85 = _84 * 16;\u000A    _aLoader_channel_array.v[0] = vload16(0, (__address_space__A_serializer float*)_A_serializer_1 + _85);\u000A    _aLoader_channel_array.v[1] = vload16(0, (__address_space__A_serializer float*)_A_serializer_2 + _85);\u000A    write_channel_intel(_aLoader_channel, _aLoader_channel_array);\u000A    (void)_aLoader_channel_array;\u000A    _addr_temp += 1;\u000A   } // for _aLoader_s0_ii\u000A  } // for _aLoader_s0_j\u000A } // for _aLoader_s0_i\u000A} // kernel kernel_aLoader\u000A#undef __address_space__A_serializer\u000A// Address spaces for kernel_uZ\u000A__kernel void kernel_uZ(\u000A const int _A_extent_0,\u000A const int _A_extent_1)\u000A{\u000A _aLoader_channel_array_t _aLoader_channel_array;\u000A _yFeeder_channel_array_t _yFeeder_channel_array;\u000A _xLoader_channel_array_t _xLoader_channel_array;\u000A _uZ_channel_array_t _uZ_channel_array;\u000A // produce uY\u000A float _uY_shreg[32];\u000A // produce uX\u000A float _uX_shreg;\u000A int _93 = _A_extent_1 >> 5;\u000A for (int _uX_s0_i = 0; _uX_s0_i < 0 + _93; _uX_s0_i++)\u000A {\u000A  int _94 = _A_extent_0 >> 5;\u000A  for (int _uX_s0_j = 0; _uX_s0_j < 0 + _94; _uX_s0_j++)\u000A  {\u000A   for (int _uX_s0_ii = 0; _uX_s0_ii < 0 + 32; _uX_s0_ii++)\u000A   {\u000A    _aLoader_channel_array_t __95 = read_channel_intel(_aLoader_channel);\u000A    _aLoader_channel_array = __95;\u000A    (void)__95;\u000A    _yFeeder_channel_array_t __96 = read_channel_intel(_yFeeder_channel);\u000A    _yFeeder_channel_array = __96;\u000A    (void)__96;\u000A    _xLoader_channel_array_t __97 = read_channel_intel(_xLoader_channel);\u000A    _xLoader_channel_array = __97;\u000A    (void)__97;\u000A    #pragma unroll\u000A    for (int _uX_s0_jj = 0; _uX_s0_jj < 0 + 32; _uX_s0_jj++)\u000A    {\u000A     float _98;\u000A     bool _99 = _uX_s0_jj == 0;\u000A     if (_99)\u000A     {\u000A      _98 = _xLoader_channel_array.s;\u000A     } // if _99\u000A     else\u000A     {\u000A      float _101 = _uX_shreg;\u000A      _98 = _101;\u000A     } // if _99 else\u000A     float _102 = _98;\u000A     _uX_shreg = _102;\u000A     (void)_102;\u000A     float _104 = _uX_shreg;\u000A     float _105 = __fpga_reg(__fpga_reg(_104));\u000A     _uX_shreg = _105;\u000A     (void)_105;\u000A     float __106 = _yFeeder_channel_array.s[_uX_s0_jj];\u000A     _uY_shreg[_uX_s0_jj] = __106;\u000A     (void)__106;\u000A     float __107 = _aLoader_channel_array.s[_uX_s0_jj];\u000A     float _109 = _uX_shreg;\u000A     float _111 = _uY_shreg[_uX_s0_jj];\u000A     float _112 = _109 * _111;\u000A     float _113 = __107 + _112;\u000A     _uZ_channel_array.s[_uX_s0_jj] = _113;\u000A     (void)_uX_s0_jj;\u000A    } // for _uX_s0_jj\u000A    write_channel_intel(_uZ_channel, _uZ_channel_array);\u000A    (void)_uZ_channel_array;\u000A   } // for _uX_s0_ii\u000A  } // for _uX_s0_j\u000A } // for _uX_s0_i\u000A} // kernel kernel_uZ\u000A// Address spaces for kernel_unloader\u000A#define __address_space__unloader_mem_channel __global\u000A__kernel void kernel_unloader(\u000A const int _A_extent_0,\u000A const int _A_extent_1,\u000A __address_space__unloader_mem_channel float *restrict _unloader_mem_channel_1,\u000A __address_space__unloader_mem_channel float *restrict _unloader_mem_channel_2)\u000A{\u000A _uZ_channel_array_t _uZ_channel_array;\u000A int _addr_temp;\u000A _addr_temp = 0;\u000A int _114 = _A_extent_1 >> 5;\u000A for (int _unloader_s0_i = 0; _unloader_s0_i < 0 + _114; _unloader_s0_i++)\u000A {\u000A  int _115 = _A_extent_0 >> 5;\u000A  for (int _unloader_s0_j = 0; _unloader_s0_j < 0 + _115; _unloader_s0_j++)\u000A  {\u000A   for (int _unloader_s0_ii = 0; _unloader_s0_ii < 0 + 32; _unloader_s0_ii++)\u000A   {\u000A    _uZ_channel_array_t __116 = read_channel_intel(_uZ_channel);\u000A    _uZ_channel_array = __116;\u000A    int _117 = _addr_temp;\u000A    int _118 = _addr_temp * 16;\u000A    vstore16(__116.v[0], 0, _unloader_mem_channel_1 + _118);\u000A    vstore16(__116.v[1], 0, _unloader_mem_channel_2 + _118);\u000A    int _119 = _addr_temp;\u000A    int _120 = _119 + 1;\u000A    _addr_temp = _120;\u000A   } // for _unloader_s0_ii\u000A  } // for _unloader_s0_j\u000A } // for _unloader_s0_i\u000A} // kernel kernel_unloader\u000A#undef __address_space__unloader_mem_channel\u000A\u000A"}]