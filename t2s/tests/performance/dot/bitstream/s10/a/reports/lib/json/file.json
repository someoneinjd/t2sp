[{"path":"/home/u146718/dot_lab/s10/a.cl", "name":"a.cl", "has_active_debug_locs":false, "absName":"/home/u146718/dot_lab/s10/a.cl", "content":"/*OpenCL C x86-64-linux-avx-avx2-debug-f16c-fma-intel_fpga-opencl-sse41*/\u000A#pragma OPENCL FP_CONTRACT ON\u000A#define float_from_bits(x) as_float(x)\u000Ainline float nan_f32() { return NAN; }\u000Ainline float neg_inf_f32() { return -INFINITY; }\u000Ainline float inf_f32() { return INFINITY; }\u000Ainline bool is_nan_f32(float x) {return isnan(x); }\u000Ainline bool is_inf_f32(float x) {return isinf(x); }\u000Ainline bool is_finite_f32(float x) {return isfinite(x); }\u000A#define sqrt_f32 sqrt \u000A#define sin_f32 sin \u000A#define cos_f32 cos \u000A#define exp_f32 exp \u000A#define log_f32 log \u000A#define abs_f32 fabs \u000A#define floor_f32 floor \u000A#define ceil_f32 ceil \u000A#define round_f32 round \u000A#define trunc_f32 trunc \u000A#define pow_f32 pow\u000A#define asin_f32 asin \u000A#define acos_f32 acos \u000A#define tan_f32 tan \u000A#define atan_f32 atan \u000A#define atan2_f32 atan2\u000A#define sinh_f32 sinh \u000A#define asinh_f32 asinh \u000A#define cosh_f32 cosh \u000A#define acosh_f32 acosh \u000A#define tanh_f32 tanh \u000A#define atanh_f32 atanh \u000A#define fast_inverse_f32 native_recip \u000A#define fast_inverse_sqrt_f32 native_rsqrt \u000A#define __address_space___shared __local\u000A\u000A\u000A// ll suffix in OpenCL is reserved for 128-bit integers.\u000A#if defined __OPENCL_VERSION__\u000A#define ADD_INT64_T_SUFFIX(x) x##l\u000A#define ADD_UINT64_T_SUFFIX(x) x##ul\u000A// HLSL doesn't have any suffixes.\u000A#elif defined HLSL_VERSION\u000A#define ADD_INT64_T_SUFFIX(x) x\u000A#define ADD_UINT64_T_SUFFIX(x) x\u000A#else\u000A#define ADD_INT64_T_SUFFIX(x) x##ll\u000A#define ADD_UINT64_T_SUFFIX(x) x##ull\u000A#endif\u000A#pragma OPENCL EXTENSION cl_intel_channels : enable\u000Atypedef union {\u000Afloat16 v[2];\u000Afloat s[32];\u000A} _xLoader__1_channel_array_t;\u000Achannel _xLoader__1_channel_array_t _xLoader__1_channel __attribute__((depth(256))) ;\u000Atypedef union {\u000Afloat16 v[2];\u000Afloat s[32];\u000A} _yLoader__1_channel_array_t;\u000Achannel _yLoader__1_channel_array_t _yLoader__1_channel __attribute__((depth(256))) ;\u000Achannel float _Out_channel __attribute__((depth(256))) ;\u000A// Address spaces for kernel_xLoader_1\u000A#define __address_space__xSerializer__1 __global\u000A__kernel void kernel_xLoader_1(\u000A const int _X_extent_0,\u000A const int _X_extent_1,\u000A __address_space__xSerializer__1 const float *restrict _xSerializer__1,\u000A __address_space__xSerializer__1 const float *restrict _xSerializer__2)\u000A{\u000A int _addr_temp = 0;\u000A for (int _xLoader__1_s0_b = 0; _xLoader__1_s0_b < 0 + _X_extent_1; _xLoader__1_s0_b++)\u000A {\u000A  int _0 = _X_extent_0 >> 5;\u000A  for (int _xLoader__1_s0_k = 0; _xLoader__1_s0_k < 0 + _0; _xLoader__1_s0_k++)\u000A  {\u000A   _xLoader__1_channel_array_t _temp;\u000A   int _1 = _addr_temp;\u000A   int _2 = _1 * 16;\u000A   _temp.v[0] = vload16(0, (__address_space__xSerializer__1 float*)(_xSerializer__1 + _2));\u000A   _temp.v[1] = vload16(0, (__address_space__xSerializer__1 float*)(_xSerializer__2 + _2));\u000A   write_channel_intel(_xLoader__1_channel, _temp);\u000A   _addr_temp += 1;\u000A  } // for _xLoader__1_s0_k\u000A } // for _xLoader__1_s0_b\u000A} // kernel kernel_xLoader_1\u000A#undef __address_space__xSerializer__1\u000A// Address spaces for kernel_yLoader_1\u000A#define __address_space__ySerializer__1 __global\u000A__kernel void kernel_yLoader_1(\u000A const int _X_extent_0,\u000A const int _X_extent_1,\u000A __address_space__ySerializer__1 const float *restrict _ySerializer__1,\u000A __address_space__ySerializer__1 const float *restrict _ySerializer__2)\u000A{\u000A int _addr_temp = 0;\u000A for (int _yLoader__1_s0_b = 0; _yLoader__1_s0_b < 0 + _X_extent_1; _yLoader__1_s0_b++)\u000A {\u000A  int _8 = _X_extent_0 >> 5;\u000A  for (int _yLoader__1_s0_k = 0; _yLoader__1_s0_k < 0 + _8; _yLoader__1_s0_k++)\u000A  {\u000A   _yLoader__1_channel_array_t _temp;\u000A   int _1 = _addr_temp;\u000A   int _2 = _1 * 16;\u000A   _temp.v[0] = vload16(0, (__address_space__ySerializer__1 float*)(_ySerializer__1 + _2));\u000A   _temp.v[1] = vload16(0, (__address_space__ySerializer__1 float*)(_ySerializer__2 + _2));\u000A   write_channel_intel(_yLoader__1_channel, _temp);\u000A   _addr_temp += 1;\u000A  } // for _yLoader__1_s0_k\u000A } // for _yLoader__1_s0_b\u000A} // kernel kernel_yLoader_1\u000A#undef __address_space__ySerializer__1\u000A// Address spaces for kernel_Z\u000A__kernel void kernel_Z(\u000A const int _X_extent_0,\u000A const int _X_extent_1)\u000A{\u000A _yLoader__1_channel_array_t _yLoader__1_channel_array;\u000A _xLoader__1_channel_array_t _xLoader__1_channel_array;\u000A for (int _uX_s0_b = 0; _uX_s0_b < 0 + _X_extent_1; _uX_s0_b++)\u000A {\u000A  int _16 = _X_extent_0 >> 5;\u000A  float _k_accumulator = 0;\u000A  for (int _uX_s0_k = 0; _uX_s0_k < 0 + _16; _uX_s0_k++)\u000A  {\u000A   _yLoader__1_channel_array_t __17 = read_channel_intel(_yLoader__1_channel);\u000A   _yLoader__1_channel_array = __17;\u000A   _xLoader__1_channel_array_t __18 = read_channel_intel(_xLoader__1_channel);\u000A   _xLoader__1_channel_array = __18;\u000A   float _kk_accumulator = 0;\u000A   #pragma unroll\u000A   for (int _uX_s0_kk = 0; _uX_s0_kk < 0 + 32; _uX_s0_kk++)\u000A   {\u000A    float __19 = _xLoader__1_channel_array.s[_uX_s0_kk];\u000A    float __20 = _yLoader__1_channel_array.s[_uX_s0_kk];\u000A    float _32 = __19 * __20;\u000A    float _33 = _kk_accumulator + _32;\u000A    _kk_accumulator = _33;\u000A   } // for _uX_s0_kk\u000A   _k_accumulator += _kk_accumulator;\u000A  } // for _uX_s0_k\u000A  write_channel_intel(_Out_channel, _k_accumulator);\u000A } // for _uX_s0_b\u000A} // kernel kernel_Z\u000A// Address spaces for kernel_unloader_1\u000A#define __address_space__unloader__1_mem_channel __global\u000A__kernel void kernel_unloader_1(\u000A const int _X_extent_1,\u000A __address_space__unloader__1_mem_channel float *restrict _unloader__1_mem_channel)\u000A{\u000A int _addr_temp;\u000A _addr_temp = 0;\u000A for (int _unloader__1_s0_b = 0; _unloader__1_s0_b < 0 + _X_extent_1; _unloader__1_s0_b++)\u000A {\u000A  float __59 = read_channel_intel(_Out_channel);\u000A  int _60 = _addr_temp;\u000A  _unloader__1_mem_channel[_60] = __59;\u000A  int _61 = _addr_temp;\u000A  int _62 = _61 + 1;\u000A  _addr_temp = _62;\u000A } // for _unloader__1_s0_b\u000A} // kernel kernel_unloader_1\u000A#undef __address_space__unloader__1_mem_channel\u000A\u000A"}]